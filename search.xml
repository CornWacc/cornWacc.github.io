<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring5新特性之WebFlux]]></title>
    <url>%2F2019%2F05%2F10%2FSpring5%E6%96%B0%E7%89%B9%E6%80%A7-WebFlux%2F</url>
    <content type="text"><![CDATA[传统Servlet模型 servlet由servlet container进行生命周期管理。container启动时构造servlet对象并调用servlet init()进行初始化；container关闭时调用servlet destory()销毁servlet；container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service()。 弊端：servlet是一个简单的网络编程模型，当请求进入servlet container时，servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的，但是一旦并发上升，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单的业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势。 spring webmvc是基于servlet之上的一个路由模型，即spring实现了处理所有request请求的一个servlet（DispatcherServlet），并由该servlet进行路由。所以spring webmvc无法摆脱servlet模型的弊端。 WebFlux SpringWebFlux是Spring5添加的新功能，WebFlux本省追随当下最火的Reactive Programming而诞生的框架。他替换了久的Servlet模型，用少量的线程处理了request,response io操作,这些线程称为Loop线程，其业务交给响应式编程框架处理，用户可以将业务中阻塞的操作提交到响应式框架的work线程中执行，而不阻塞的操作依然可以在Loop线程中进行处理，大大提高了Loop线程的利用率 关于WebFlux WebFlux是一个非阻塞异步的框架，主要有两大优势。 非阻塞式 在servlet3.1提供了非阻塞的API，WebFlux提供了一种比其更完美的解决方案。使用非阻塞的方式可以利用较小的线程或硬件资源来处理并发进而提高其可伸缩性。 函数式编程端点 Spring5必须让你使用java8，那么函数式编程就是java8重要的特点之一，而WebFlux支持函数式编程来定义路由端点处理请求。 Demo1.编写Http请求处理器 2.编写路由 3.SpringBoot的启动类(这个就不贴图了,但是需要开启对WebFlux的支持)4.此处在日志中会现实表示路由新建成功12019-05-10 10:53:09.626 INFO 82487 --- [ main] o.s.w.r.f.s.s.RouterFunctionMapping : Mapped ((GET &amp;&amp; /hello) &amp;&amp; Accept: [text/plain]) -&gt; com.corn.spring.webflux.flux.FluxRouter$$Lambda$214/332365138@40cb698e]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring-Beans`s Study]]></title>
    <url>%2F2019%2F05%2F08%2FSpring-Beans%2F</url>
    <content type="text"><![CDATA[1.什么是SpringBean1.1 Spring Bean是被实例的，组装的以及被Spring管理的Java对象。1.2 Spring 容器会自动完成@Bean对象的实例化。2.Spring-Bean包的内置配置 3.SpringBean中的核心类介绍3.1 Spring中有最核心的两个类3.1.1 Default该类是整个Bean加载的核心部分，是Spring注册及加载bean的默认实现。它继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory及BeanDefinitionRegistry接口。 以下是该类的层次结构图(蓝色为类,绿色为接口) --------------- 类解析(依赖从右往左) --------------------- AliasRegistry(别名注册接口) 用于定义对别名的简单增删改等操作 SimpleAliasRegistry(别名的缓存) 主要使用map作为alias的缓存，并对接口AliasRegistry进行实现 DefaultSingletonBeanRegistry(单例的操作) 对接口SingletonBeanRegistry各函数的实现 SingletonBeanRegistry 对单例的注册和获取 FactoryBeanRegistrySupport 在DefaultSingletonBeanRegistry基础上增加了对FactoryBean的特殊处理功能,对单例的一些操作进行了优化 AbstractBeanFactory 综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能,主要提供了这样的三个功能: 别名管理,单例创建与注册,工厂方法FactoryBean支持 BeanFactory 定义获取Bean及Bean的各种属性。 HierarchicalBeanFactory 继承BeanFactory，也就是在BeanFactroy的功能的基础上增加了对parentFactroy的支持 ConfigurableBeanFactory 提供配置Factory的各种方法 AutowireCapableBeanFactory 提供创建Bean，自动注入，初始化以及应用Bean的后处理器 AbstractAutowireCapableBeanFactory 综合AbstractBeanFactory并对接口AutowireCapableBeanFactory进行实现 ListableBeanFactory 根据各种条件获取bean的配置清单 ConfigurableListableBeanFactory BeanFactory的配置清单，指定忽略类型及接口等 BeanDefinitionRegistry 定义对BeanDefinition的各种增删改操作]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring常用api]]></title>
    <url>%2F2019%2F04%2F02%2FSpring%E5%B8%B8%E7%94%A8Api%2F</url>
    <content type="text"><![CDATA[1.上下文加载中bean1.AnnotationConfigApplicationContext:从上下文中获取Bean 2.AnnotationConfigWebApplicationContext:从一个或多个基于Java的配置累中加载Spring Web上下文 3.ClassPathXmlApplicationContext:从类路径下加载xml文件获取bean 4.FileSystemXmlApplicationContext:从文件系统下加载xml文件获取bean 5.XmlWebApplicationContext:从Web应用下的一个或多个XML配置文件中加载上下文 2.Bean扫描2.1.ClassPathBeanDefinitionScanner2.1.1 作用:该类根据提供个基础包名，扫描classpath下与该包名的路径下，找到符合条件的类并注册到spring的BeanDefinition注册器中]]></content>
  </entry>
  <entry>
    <title><![CDATA[ByteBuf`s Study]]></title>
    <url>%2F2019%2F03%2F28%2FByteBuf%60s%20Study%2F</url>
    <content type="text"><![CDATA[1.ByteBuf介绍摘抄自掘金小册 Netty入门与实战(by 闪电侠) 1.1.ByteBuf结构1. ByteBuf是一个字节容器(有三个部分),第一个部分是已经丢弃的字节(数据是无效的),第二部分是可读字节,这部分是ByteBuf的主题数据,从ByteBuf里面读取的数据都来自这一部分。最后一部分是可写字节,所有写到ByteBuf的数据都会写到最后一段。最后虚线部分是指还可扩多少容。 2.readerIndex:当前指针位置,ByteBuf每读取一个字节,该参数自增1,ByteBuf里面总共有writerIndex(写入指针)-readerIndex个字节可读,所以当writerIndex等于readerIndex时,ByteBuf不可读。 3.每写一个字节writerIndex增1,直到增加到当前容量(capacity)时,该ByteBuf不可写。如果当前容量不足,可以进行扩容,直到capacity增加到最大容量maxCapacity,当超过最大容量时就会报错。 4.Netty运用ByteBuf这种数据结构可以有效的区分可读可写的数据,读写之间没有冲突。 1.2.ByteBuf Api1.capacity():用于表示ByteBuf占用了多少字节的内存(丢失的,可读的,可写的) 2.maxCapacity():用于表示该ByteBuf最大能够占用多少内存 3.readableBytes():表示当前可读的字节数(capacity-readerIndex)。 4.isReadable():判断当前ByteBuf是否还可读 5.writableBytes():表示当前可写的字节数(capacity-writerIndex)。 6.isWritable():表示当前ByteBuf是否还可写,如果不可写将会对当前的容量进行扩容,直到扩容到最大容量时不可写 7.maxWritableBytes():表示当前还可写多少字节(maxcapacity-writerIndex) 8.readerIndex:获取当前读取到的字节下标 readerIndex(i):获取当前设置指针的ByteBuf抽象 writeIndex(),writerIndex(i)同理 9.writeBytes(byte[] b):表示把字节数组的内容写入到ByteBuf里面。 readBytes(byte[] red):表示把bytebuf里的字节全部读取到字节数组里。]]></content>
  </entry>
  <entry>
    <title><![CDATA[线程池`s Study]]></title>
    <url>%2F2019%2F03%2F27%2FThreadPool%60s%20Study%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Netty`s Study]]></title>
    <url>%2F2019%2F03%2F26%2FNetty%60s%20Study%2F</url>
    <content type="text"><![CDATA[1.Netty是什么Netty封装了JDK的NIO,是一个异步事件驱动的网络应用框架,用于快速开发可维护的高性能服务器和客户端。 2.为什么不用原生自带的NIO1.使用JDK自带的NIO需要了解太多的概念,编程复杂。 2.Netty底层的IO模型随意切换。 3.Netty自带拆包解包,异常监测 4.Netty解决了很逗JDK包括空轮询的Bug 5.自带各种协议栈 6.Netty底层对线程,selector做了很多细小的优化,精心设计的reactor线程模型做到非常高效的并发处理 7.Netty的健壮性非常强大 3.Netty实现服务端 3.1.启动流程1).首先创建了两个NioEventLoogGroup,这两个对象可以看做是传统IO变成模型的两个线程组,boss表示端口监听,worker表示处理每一条连接数据的读写的线程组。 2).ServerBootStrap:引导类,这个类将引导我们进行服务端的启动工作 3). .group是给引导类配置两大线程组,这样引导类的线程模型也就定型了 4). .channel(指定IO模型): NioServerSocketChannel Nio模型 OioServerSocketChannel Bio模型 5). .childHandler方法:给引导类创建一个ChannelInitializer用于定义后续每条连接的数据读写,业务处理逻辑。 ChannelInitializer:这个类中需定义一个泛型参数,为定义主通道处理器,对Nio的连接抽象。 6).最后操作时可以绑定端口号:serverBootstrap.bind(自定义端口号),此方法是异步的。可以拓展为端口递增绑定 7). 附上(Bio引导设置): 3.2.总结:要启动一个Netty服务端必须要指定三类属性1.线程模型(监听线程组,读写处理逻辑线程组) 2.IO模型(Nio,Bio) 3.连续读写处理逻辑 4.Netty实现客户端 4.1.启动流程1.和服务端启动类似(定义线程组,定义io模型,定义io处理模型处理逻辑) 2.Bootstrap:客户端的引导类负责客户端以及连接服务端 3.connect方法:用于连接,这个方法有两个参数(Ip/域名,端口号),这个方法也是一个异步。可以通过addListener方法监听连接是否成功。 5.Netty实现双向通信1.上述已经讲了Netty怎么实现两个端的建立,需要实现两端通信则只需要在IO读写逻辑(ChannelInitializer)中进行相关的逻辑操作。 5.1 服务端读取写入 1234567891011121314151617181920212223242526272829303132333435363738/** * 服务端自定义逻辑处理器 * 1.需继承实现了ChannelHandler该接口的类,此处运用的是ChannelInboundHandlerAdapter * * 方法解释： * 1.channelRead:该方法是在接收到客户端发来的数据后被回调 * 2.writeAndFlush:写出二进制 * */public class FirstServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext channelHandlerContext, Object s)&#123; //读取客户端信息 System.out.println(&quot;接受到客户端消息:&quot;+new Date()+&quot;:&quot;+s); //写出数据 System.out.println(new Date()+&quot;服务端写出数据:&quot;); ByteBuf byteBuf = getByteBuf(channelHandlerContext); //数据写出 channelHandlerContext.writeAndFlush(byteBuf); &#125; private ByteBuf getByteBuf(ChannelHandlerContext ctx)&#123; //获取ByteBuf抽象,生成一个ByteBuf ByteBuf byteBuf = ctx.alloc().buffer(); try&#123; byte[] bytes = &quot;欢迎连接!&quot;.getBytes(&quot;utf-8&quot;); //填充ByteBuf byteBuf.writeBytes(bytes); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return byteBuf; &#125;&#125; 5.2 客户端读取写入 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 自定义客户端读写逻辑处理器 * */public class FirstClientHandler extends ChannelInboundHandlerAdapter &#123; /** * 这个方法会在客户端建立连接成功后被调用 * */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(new Date() + &quot;:客户端写出数据:&quot;); //1.获取数据 ByteBuf byteBuf = getByteBuf(ctx); //2.写出 ctx.channel().writeAndFlush(byteBuf); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf byteBuf = (ByteBuf) msg; System.out.println(&quot;获取到服务器端信息:&quot;+byteBuf.toString(Charset.forName(&quot;UTF-8&quot;))); &#125; private ByteBuf getByteBuf(ChannelHandlerContext ctx) throws UnsupportedEncodingException &#123; //1.获取二进制抽象 ByteBuf ctx.alloc方法是获取一个ByteBuf的内存管理器 ByteBuf byteBuf = ctx.alloc().buffer(); //2.准备数据,指定字符串的字符集为UTF-8 byte[] bytes = &quot;你好&quot;.getBytes(&quot;UTF-8&quot;); //3.填充数据到 ByteBuf byteBuf.writeBytes(bytes); return byteBuf; &#125;&#125; 6.总结1.在客户端和服务端的逻辑处理都是在启动的时候,通过给逻辑处理链pipeline添加逻辑处理器,用于便携数据的读写逻辑。 2.在客户端连接成功后回调逻辑处理器的channelActive()方法。 3.无论是服务端还是客户端收到数据后都会调用channelRead方法。 4.写数据需调用writeAndFlush方法,客户端与服务端交互的二进制数据载体为ByteBuf,ByteBuf通过连接的内存管理器创建,字节数据填充到ByteBuf之后才能写到对端。]]></content>
  </entry>
</search>
