





<!doctype html>
<html lang="zh-CN">

<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js">
</script>
<link href="/plugins/code-theme/tomorrow.css" type="text/css" rel="stylesheet">
<link rel="stylesheet" href="/plugins/github-markdown.css">

<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8" name="viewport" content="width=device-width,initial-scale=1">
  
    
    
      <link rel="stylesheet" href="/css/legend.css">
    
  
</head>

<body id="body-x">
<div id="layout-content">
  <div id="menu-outer-x">
  <div id="menu-inner">
    
    
    <div id="site-title">
      CornWacc`s Blog
    </div>
    

     
    <div>
    
      
      <a href="/">Main</a>
      
    
      
      <a href="/archives">Archives</a>
      
    
    </div>
  </div>
</div> 
  <div id="content-outer">
    <div id="content-inner">
      
      
  <article class="markdown-body">
    <h2 id="post-title">ByteBuf`s Study
       
        <div id="post-time" datetime="2019-03-28T01:04:40.000Z">
          2019-03-28
        </div>
      
    </h2>
    <h1 id="1-ByteBuf介绍"><a href="#1-ByteBuf介绍" class="headerlink" title="1.ByteBuf介绍"></a>1.ByteBuf介绍</h1><p><em>摘抄自掘金小册 Netty入门与实战(by 闪电侠)</em><br><img src="https://s2.ax1x.com/2019/03/28/Adfscd.png" alt="&quot;&quot;"></p>
<h2 id="1-1-ByteBuf结构"><a href="#1-1-ByteBuf结构" class="headerlink" title="1.1.ByteBuf结构"></a>1.1.ByteBuf结构</h2><pre><code>1. ByteBuf是一个字节容器(有三个部分),第一个部分是已经丢弃的字节(数据是无效的),第二部分是可读字节,这部分是ByteBuf的主题数据,从ByteBuf里面读取的数据都来自这一部分。最后一部分是可写字节,所有写到ByteBuf的数据都会写到最后一段。最后虚线部分是指还可扩多少容。

2.readerIndex:当前指针位置,ByteBuf每读取一个字节,该参数自增1,ByteBuf里面总共有writerIndex(写入指针)-readerIndex个字节可读,所以当writerIndex等于readerIndex时,ByteBuf不可读。

3.每写一个字节writerIndex增1,直到增加到当前容量(capacity)时,该ByteBuf不可写。如果当前容量不足,可以进行扩容,直到capacity增加到最大容量maxCapacity,当超过最大容量时就会报错。

4.Netty运用ByteBuf这种数据结构可以有效的区分可读可写的数据,读写之间没有冲突。
</code></pre><h2 id="1-2-ByteBuf-Api"><a href="#1-2-ByteBuf-Api" class="headerlink" title="1.2.ByteBuf Api"></a>1.2.ByteBuf Api</h2><pre><code>1.capacity():用于表示ByteBuf占用了多少字节的内存(丢失的,可读的,可写的)

2.maxCapacity():用于表示该ByteBuf最大能够占用多少内存

3.readableBytes():表示当前可读的字节数(capacity-readerIndex)。

4.isReadable():判断当前ByteBuf是否还可读

5.writableBytes():表示当前可写的字节数(capacity-writerIndex)。

6.isWritable():表示当前ByteBuf是否还可写,如果不可写将会对当前的容量进行扩容,直到扩容到最大容量时不可写

7.maxWritableBytes():表示当前还可写多少字节(maxcapacity-writerIndex)

8.readerIndex:获取当前读取到的字节下标
  readerIndex(i):获取当前设置指针的ByteBuf抽象
  writeIndex(),writerIndex(i)同理

9.writeBytes(byte[] b):表示把字节数组的内容写入到ByteBuf里面。
  readBytes(byte[] red):表示把bytebuf里的字节全部读取到字节数组里。
</code></pre>
  </article>

  
    
    
      <div id="page-prev-next">
        
        
          <a id="page-prev-a" href="/2019/04/02/Spring常用Api/"> ← Spring常用api </a>
        

        
        
          <a id="page-next-a" href="/2019/03/27/ThreadPool`s Study/"> 线程池`s Study → </a>
        
      </div>
    
    
    
    
      
      <div id="play-button" style="background-color: gray; border: solid 2px gray;">
  <img id="play-img" src="/images/playback_play.png">
</div>
<audio id="bgaudio" loop="loop" preload="none"> 
  <source src="http://cdn.calm.com/scenes/scene-Qqkzy9k7Eo.m4a?v=1418162240715" type="audio/mpeg">
</audio>

<script>
$(document).ready(function(){
  //播放按钮点击
  var audio = $("#bgaudio")[0];
  var img = $("#play-img")[0];
  $("#play-button").click(function(){ 
    if (audio.paused || audio.ended) {
      audio.play();
      img.src = "/images/playback_pause.png";
    } else {
      audio.pause();
      img.src = "/images/playback_play.png";
    }
  });
});
</script>
    

    
    


  

    </div>
  </div>
</div>


</body>
</html>


<script>
$(window).on('load', function(){
   $('pre').addClass('prettyprint').attr('style', 'overflow:auto;');
   prettyPrint();
 });
</script>

